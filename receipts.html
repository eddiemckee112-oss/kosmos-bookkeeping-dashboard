<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Kosmos Bookkeeping ‚Äî Receipts</title>

  <!-- Supabase -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <!-- Tesseract (local OCR) -->
  <script src="https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js"></script>

  <!-- pdf.js to render PDFs -->
  <script src="https://unpkg.com/pdfjs-dist@4.6.82/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://unpkg.com/pdfjs-dist@4.6.82/build/pdf.worker.min.js";</script>

  <style>
    :root{--bg:#fafafa;--card:#fff;--border:#e5e7eb;--muted:#6b7280;--ok:#0a7a33;--err:#b00020;--ink:#111;--btn:#111;--btnH:#333;}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--ink);}
    header{background:#fff;border-bottom:1px solid var(--border);padding:14px 24px;display:flex;justify-content:space-between;align-items:center;}
    header h1{font-size:1.2rem;margin:0;}
    nav a{margin-left:16px;color:var(--ink);text-decoration:none;font-weight:500;padding:6px 10px;border-radius:8px;}
    nav a:hover,nav a.active{background:#111;color:#fff;}
    main{padding:32px;max-width:1200px;margin:auto;}
    h2{margin-top:0}
    .grid{display:grid;grid-template-columns:560px 1fr;gap:24px;align-items:start;}
    @media (max-width:1200px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:20px;margin-top:20px;}
    label{display:block;margin-top:.7rem;font-weight:600;}
    input,select{width:100%;padding:.6rem .7rem;border:1px solid #cfcfcf;border-radius:10px;margin-top:.35rem;background:#fff;}
    input[readonly]{background:#f7f7f7;}
    button{padding:.6rem 1rem;border-radius:10px;border:1px solid #bbb;background:var(--btn);color:#fff;cursor:pointer;}
    button:hover{background:var(--btnH);}
    .secondary{background:#f7f7f7;color:#111;border-color:#d0d0d0;}
    .secondary:hover{background:#eee;}
    .rowbtns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;align-items:center;}
    table{width:100%;border-collapse:collapse;font-size:14px;}
    th,td{padding:8px 10px;border-bottom:1px solid var(--border);text-align:left;}
    th{background:#f6f7f8;position:sticky;top:0;z-index:1;}
    .right{text-align:right;}
    .muted{color:var(--muted)} .ok{color:var(--ok)} .err{color:var(--err)}
    .chip{font-size:12px;background:#eef2ff;border:1px solid #c7d2fe;padding:2px 6px;border-radius:999px;}
    small.muted{color:var(--muted);display:block;margin-top:.25rem;}
    progress{width:100%;}
    canvas{width:100%;max-width:520px;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:crosshair;}
    .hint{font-size:12px;color:var(--muted);}
    .switch{display:flex;align-items:center;gap:8px;}
  </style>
</head>
<body>
<header>
  <h1>üì∏ Kosmos Bookkeeping</h1>
  <nav>
    <a href="index.html">Dashboard</a>
    <a href="receipts.html" class="active">Receipts</a>
    <a href="transactions.html">Transactions</a>
    <a href="reports.html">Reports</a>
  </nav>
</header>

<main>
  <h2>Receipt Upload & Scanner (Local OCR + Zoom/Crop + Magnifier + Auto-Detect)</h2>
  <p class="muted">All scanning runs in your browser. Use zoom/rotate/crop or auto-detect the totals area; then save to <code>public.receipts</code>.</p>

  <div class="grid">
    <div>
      <!-- Preview + controls -->
      <div class="card">
        <h3>Preview & Enhance</h3>
        <div class="rowbtns">
          <input type="file" id="fileInput" accept="image/*,.pdf"/>
          <button id="rotateBtn" class="secondary">Rotate 90¬∞</button>
          <label class="switch">
            <span class="hint">Zoom</span>
            <input id="zoom" type="range" min="0.5" max="3" step="0.1" value="1" style="width:180px;">
            <span id="zoomVal" class="hint">1.0√ó</span>
          </label>
          <label class="switch">
            <input id="magnifyToggle" type="checkbox">
            <span class="hint">Magnifier</span>
          </label>
          <label class="switch">
            <span class="hint">Strength</span>
            <input id="magnifyStrength" type="range" min="1.5" max="4" step="0.1" value="2">
          </label>
          <button id="clearCrop" class="secondary" title="Clear crop (double-click canvas also clears)">Clear crop</button>
          <button id="autoDetect" class="secondary" title="Find the totals area automatically">Auto-Detect Totals</button>
        </div>
        <small class="muted">Tip: click-drag on the canvas to draw a crop box. Drag corners to adjust. Double-click to clear. Hover with ‚ÄúMagnifier‚Äù on to zoom in.</small>
        <div style="margin-top:10px;position:relative;">
          <canvas id="preview" width="520" height="520" aria-label="preview"></canvas>
        </div>
        <div id="scanStatus" class="muted" style="margin-top:.5rem;"></div>
        <progress id="scanProgress" max="1" value="0" style="display:none;"></progress>
        <div class="rowbtns">
          <button id="scanBtn" class="secondary">Scan with AI (local)</button>
        </div>
      </div>

      <!-- Fields + save -->
      <div class="card">
        <h3>Details</h3>
        <label>Vendor<input id="vendor" placeholder="e.g., Sysco, Costco"/></label>
        <label>Date<input id="rdate" type="date"/></label>
        <label>Total<input id="total" type="number" step="0.01"/></label>
        <label>Tax<input id="tax" type="number" step="0.01"/></label>
        <label>Subtotal (auto)<input id="subtotal" type="number" step="0.01" readonly/></label>
        <label>Category<input id="category" placeholder="Category"/></label>
        <label>Source<input id="source" placeholder="Bank/Card"/></label>
        <label>Notes<input id="notes" placeholder="optional"/></label>
        <div class="rowbtns"><button id="uploadBtn">Upload & Save</button></div>
        <p id="msg" class="muted"></p>
      </div>

      <!-- Automation -->
      <div class="card">
        <h3>Automation</h3>
        <div class="rowbtns">
          <button id="btnApply" class="secondary">Apply Rules</button>
          <select id="matchMode"><option value="strict" selected>Strict</option><option value="fuzzy">Fuzzy</option></select>
          <button id="btnMatch" class="secondary">Match</button>
          <button id="exportBtn">Export Accountant CSV</button>
        </div>
        <p id="autoMsg" class="muted"></p>
      </div>
    </div>

    <!-- Unmatched list -->
    <div class="card">
      <h3>Unmatched Receipts</h3>
      <div style="max-height:540px;overflow:auto;margin-top:8px;">
        <table id="unmatchedTable">
          <thead><tr><th>Date</th><th>Vendor</th><th class="right">Total</th><th class="right">Tax</th><th>Category</th><th>Source</th><th>Image</th></tr></thead>
          <tbody><tr><td colspan="7" class="muted">Loading‚Ä¶</td></tr></tbody>
        </table>
      </div>
      <button id="refreshBtn" class="secondary" style="margin-top:8px;">Refresh</button>
    </div>
  </div>
</main>

<script>
/* ---------- Supabase ---------- */
const SUPABASE_URL="https://advihqhjjlxumgdlbwui.supabase.co";
const SUPABASE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFkdmlocWhqamx4dW1nZGxid3VpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwMTg0MzIsImV4cCI6MjA3NjU5NDQzMn0.kVlaPQg2_o9DGJYv22Dgca7veok4drF6kgLPy2wPBeY";
const sb=supabase.createClient(SUPABASE_URL,SUPABASE_KEY);
const BUCKET="receipts-warm";

/* ---------- DOM helpers ---------- */
const qs=id=>document.getElementById(id);
const msgEl=qs("msg"), autoMsg=qs("autoMsg");
const statusEl=qs("scanStatus"), prog=qs("scanProgress");

/* ---------- Preview / canvas state ---------- */
let baseImage = null;      // HTMLImageElement of the source (image or first PDF page)
let rotation = 0;          // 0, 90, 180, 270
let crop = null;           // {x,y,w,h} in canvas coords
const canvas = qs("preview");
const ctx = canvas.getContext("2d");
const Z = qs("zoom");

/* ---------- UI: zoom / rotate / crop ---------- */
qs("zoom").addEventListener("input", ()=>{ qs("zoomVal").textContent = `${Number(Z.value).toFixed(1)}√ó`; drawPreview(); });
qs("rotateBtn").addEventListener("click", ()=>{ rotation = (rotation + 90) % 360; drawPreview(); });
qs("clearCrop").addEventListener("click", ()=>{ crop = null; drawPreview(); });
canvas.addEventListener("dblclick", ()=>{ crop = null; drawPreview(); });

let dragging = false, dragHandle = null;
let startX=0, startY=0;

function hitHandle(mx,my){
  if(!crop) return null;
  const handles = [
    {n:"nw",x:crop.x,y:crop.y},
    {n:"ne",x:crop.x+crop.w,y:crop.y},
    {n:"sw",x:crop.x,y:crop.y+crop.h},
    {n:"se",x:crop.x+crop.w,y:crop.y+crop.h}
  ];
  for(const h of handles){
    if(Math.abs(mx-h.x)<=6 && Math.abs(my-h.y)<=6) return h.n;
  }
  return null;
}
canvas.addEventListener("mousedown",(e)=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  dragHandle = hitHandle(mx,my);
  dragging = true; startX = mx; startY = my;
  if(!dragHandle){ crop = {x:mx,y:my,w:0,h:0}; }
});
canvas.addEventListener("mousemove",(e)=>{
  // magnifier always draws on move (below)
  if(dragging){
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    if(dragHandle && crop){
      if(dragHandle==="nw"){ crop.w += crop.x-mx; crop.h += crop.y-my; crop.x=mx; crop.y=my; }
      if(dragHandle==="ne"){ crop.w = mx-crop.x; crop.h += crop.y-my; crop.y=my; }
      if(dragHandle==="sw"){ crop.w += crop.x-mx; crop.x=mx; crop.h = my-crop.y; }
      if(dragHandle==="se"){ crop.w = mx-crop.x; crop.h = my-crop.y; }
      drawPreview();
    }else if(crop){
      crop.w = mx - startX; crop.h = my - startY;
      if(crop.w<0){ crop.x = mx; crop.w = startX-mx; }
      if(crop.h<0){ crop.y = my; crop.h = my-startY; }
      drawPreview();
    } else {
      drawPreview();
    }
    drawMagnifier(e);
  } else {
    drawPreview();
    drawMagnifier(e);
  }
});
window.addEventListener("mouseup",()=>{ dragging=false; dragHandle=null; });

/* ---------- Magnifier ---------- */
function drawMagnifier(evt){
  if(!qs("magnifyToggle").checked || !baseImage) return;
  const rect=canvas.getBoundingClientRect();
  const mx=evt.clientX-rect.left, my=evt.clientY-rect.top;
  const strength = Number(qs("magnifyStrength").value); // 1.5‚Äì4
  const radius = 60;                                     // lens radius px

  // Build a temp snapshot of the current canvas
  const snap = ctx.getImageData(0,0,canvas.width,canvas.height);
  // Draw lens border
  ctx.putImageData(snap,0,0);
  ctx.save();
  ctx.beginPath();
  ctx.arc(mx,my,radius,0,Math.PI*2);
  ctx.clip();

  // Zoomed draw from current canvas
  ctx.drawImage(canvas,
    mx - radius/strength, my - radius/strength, (radius*2)/strength, (radius*2)/strength,
    mx - radius,          my - radius,          radius*2,            radius*2
  );
  ctx.restore();

  // ring
  ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(mx,my,radius,0,Math.PI*2); ctx.stroke();
}

/* ---------- Image/PDF loading ---------- */
qs("fileInput").addEventListener("change", async ()=>{
  rotation = 0; crop = null;
  const f = qs("fileInput").files?.[0];
  if(!f){ baseImage=null; clearCanvas(); return; }
  if(f.type === "application/pdf"){
    const ab = await f.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data:ab}).promise;
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({scale:2});
    const c = document.createElement("canvas");
    c.width = viewport.width; c.height = viewport.height;
    await page.render({canvasContext:c.getContext("2d"), viewport}).promise;
    baseImage = await loadImage(c.toDataURL("image/png",1.0));
  }else{
    baseImage = await loadImage(URL.createObjectURL(f));
  }
  drawPreview();
});

function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=src;
  });
}
function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

/* ---------- Draw preview with zoom/rotation & crop overlay ---------- */
function drawPreview(){
  clearCanvas();
  if(!baseImage) return;

  const zoom = Number(Z.value);
  const imgW = (rotation%180===0) ? baseImage.width : baseImage.height;
  const imgH = (rotation%180===0) ? baseImage.height : baseImage.width;
  const scale = Math.min(canvas.width/imgW, canvas.height/imgH) * zoom;

  const drawW = Math.round(imgW*scale);
  const drawH = Math.round(imgH*scale);
  const dx = Math.round((canvas.width - drawW)/2);
  const dy = Math.round((canvas.height - drawH)/2);

  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate(rotation*Math.PI/180);
  ctx.drawImage(baseImage, -drawW/2, -drawH/2, drawW, drawH);
  ctx.restore();

  ctx.strokeStyle="#d0d0d0"; ctx.strokeRect(dx,dy,drawW,drawH);

  if(crop){
    ctx.save();
    ctx.strokeStyle="#2563eb"; ctx.lineWidth=2; ctx.setLineDash([6,4]);
    ctx.strokeRect(crop.x, crop.y, crop.w, crop.h);
    ctx.setLineDash([]); ctx.fillStyle="#2563eb";
    for(const [hx,hy] of [[crop.x,crop.y],[crop.x+crop.w,crop.y],[crop.x,crop.y+crop.h],[crop.x+crop.w,crop.y+crop.h]]){
      ctx.fillRect(hx-3,hy-3,6,6);
    }
    ctx.restore();
  }
}

/* ---------- Build OCR-ready image (apply zoom/rotation & crop) ---------- */
async function buildOcrDataURL(){
  if(!baseImage) throw new Error("Pick a file first.");
  const zoom = Number(Z.value);
  const imgW = (rotation%180===0) ? baseImage.width : baseImage.height;
  const imgH = (rotation%180===0) ? baseImage.height : baseImage.width;
  const fitScale = Math.min(canvas.width/imgW, canvas.height/imgH) * zoom;

  const drawW = Math.round(imgW*fitScale);
  const drawH = Math.round(imgH*fitScale);
  const dx = Math.round((canvas.width - drawW)/2);
  const dy = Math.round((canvas.height - drawH)/2);

  let srcRect;
  if(crop){
    const sx = Math.max(0, Math.round((crop.x - dx) / fitScale));
    const sy = Math.max(0, Math.round((crop.y - dy) / fitScale));
    const sw = Math.max(1, Math.round(crop.w / fitScale));
    const sh = Math.max(1, Math.round(crop.h / fitScale));
    srcRect = {sx,sy,sw,sh};
  }else{
    srcRect = {sx:0,sy:0,sw:imgW,sh:imgH};
  }

  // rotate original into an upright buffer first
  const upright = document.createElement("canvas");
  upright.width = imgW; upright.height = imgH;
  const ug = upright.getContext("2d");
  if(rotation!==0){
    const buf = document.createElement("canvas");
    if(rotation%180===0){ buf.width=baseImage.width; buf.height=baseImage.height; }
    else { buf.width=baseImage.height; buf.height=baseImage.width; }
    const bg = buf.getContext("2d");
    bg.translate(buf.width/2, buf.height/2);
    bg.rotate(rotation*Math.PI/180);
    bg.drawImage(baseImage, -baseImage.width/2, -baseImage.height/2);
    ug.drawImage(buf, 0,0, buf.width, buf.height, 0,0, imgW, imgH);
  }else{
    ug.drawImage(baseImage,0,0);
  }

  // final high-res crop
  const out = document.createElement("canvas");
  const upscale = 2;
  out.width = Math.min(2400, srcRect.sw * upscale);
  out.height = Math.min(2400, srcRect.sh * upscale);
  const g = out.getContext("2d");
  g.imageSmoothingQuality="high";
  g.drawImage(upright, srcRect.sx, srcRect.sy, srcRect.sw, srcRect.sh, 0,0, out.width, out.height);

  // grayscale + slight contrast
  const id = g.getImageData(0,0,out.width,out.height);
  const d = id.data;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], gg=d[i+1], b=d[i+2];
    let y = 0.299*r + 0.587*gg + 0.114*b;
    y = (y-128)*1.15 + 128;
    y = Math.max(0, Math.min(255, y));
    d[i]=d[i+1]=d[i+2]=y;
  }
  g.putImageData(id,0,0);

  return out.toDataURL("image/png",1.0);
}

/* ---------- OCR & parsing ---------- */
function to2(n){ if(n===null||n===undefined||n==="") return ""; const v=Number(n); return Number.isNaN(v)?"":v.toFixed(2); }
function updateSubtotalPreview(){ const t=parseFloat(qs("total").value)||0; const x=parseFloat(qs("tax").value)||0; qs("subtotal").value=(t-x).toFixed(2); }
qs("total").addEventListener("input",updateSubtotalPreview);
qs("tax").addEventListener("input",updateSubtotalPreview);

function findDate(text){
  const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const rx=[/\b(\d{4})[-\/\.](\d{2})[-\/\.](\d{2})\b/,/\b(\d{2})[-\/\.](\d{2})[-\/\.](\d{4})\b/,/\b([A-Za-z]{3,9})\s+(\d{1,2}),\s*(\d{4})\b/];
  for(const line of lines){
    for(const r of rx){
      const m=line.match(r); if(!m) continue;
      if(r===rx[0]) return `${m[1]}-${m[2]}-${m[3]}`;
      if(r===rx[1]){ const mm=m[1].padStart(2,"0"), dd=m[2].padStart(2,"0"); return `${m[3]}-${mm}-${dd}`; }
      if(r===rx[2]){ const months=["january","february","march","april","may","june","july","august","september","october","november","december"]; const mm=String(months.indexOf(m[1].toLowerCase())+1).padStart(2,"0"); const dd=String(m[2]).padStart(2,"0"); return `${m[3]}-${mm}-${dd}`; }
    }
  }
  return null;
}
function findAmounts(text){
  const lines=text.split(/\r?\n/);
  const rxAmt=/([-+]?\$?\(?\d{1,3}(?:[,\s]\d{3})*(?:\.\d{2})?\)?)/g;
  const cands=[];
  lines.forEach((line,i)=>{
    const lower=line.toLowerCase();
    const nearTotal=/total|amount due|grand\s*total|balance/i.test(lower);
    const nearTax=/\b(hst|gst|pst|tps|tvq|tax)\b/i.test(lower);
    for(const m of line.matchAll(rxAmt)){
      let s=m[1]; const neg=/^\(.*\)$/.test(s)||s.startsWith("-"); s=s.replace(/[\$\(\),\s]/g,"");
      const v=Number(s); if(Number.isFinite(v)) cands.push({v:Math.abs(v), nearTotal, nearTax, i});
    }
  });
  const tax = cands.find(c=>c.nearTax)?.v ?? 0;
  let total = cands.find(c=>c.nearTotal)?.v ?? 0;
  if(!total) total = cands.sort((a,b)=>b.v-a.v)[0]?.v ?? 0;
  return {total: total||null, tax: tax||0};
}
function findVendor(text){
  const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  for(let i=0;i<Math.min(8,lines.length);i++){
    const s=lines[i];
    if(/\d{5,}/.test(s)) continue;
    if(/invoice|receipt|sale|order|transaction|subtotal|total|tax/i.test(s)) continue;
    if(s.length>=3) return s.replace(/\s{2,}/g," ");
  }
  return lines[0]||null;
}
function extractFields(text){
  const date=findDate(text);
  const {total,tax}=findAmounts(text);
  const vendor=findVendor(text);
  return {vendor,date,total,tax,rawText:text};
}

/* ---------- OCR with Tesseract ---------- */
async function ocrDataUrl(dataUrl, wantLayout=false){
  prog.style.display="block"; prog.value=0; statusEl.textContent="Starting OCR‚Ä¶";
  const worker = await Tesseract.createWorker("eng", 1, {
    logger: m => { if(m.status) statusEl.textContent = `${m.status}‚Ä¶`; if(m.progress!=null) prog.value=m.progress; }
  });
  const { data } = await worker.recognize(dataUrl);
  await worker.terminate();
  prog.style.display="none";
  return wantLayout ? data : { text:data.text };
}

/* ---------- Auto-Detect Totals (uses bounding boxes) ---------- */
async function autoDetectTotals(){
  if(!baseImage){ statusEl.className="err"; statusEl.textContent="Pick a file first."; return; }
  try{
    statusEl.className="muted"; statusEl.textContent="Finding totals region‚Ä¶";
    // Build full, upright image (ignoring manual crop)
    crop = null;
    const fullUrl = await buildOcrDataURL(); // with upscale/contrast already
    // We need layout data (words with bbox)
    const layout = await ocrDataUrl(fullUrl, true);

    // Tesseract layout structure: layout.words[] with text + bbox (x0,y0,x1,y1) in image px
    const words = (layout.words || layout.lines || []);
    const hits = [];
    const rx = /(grand\s*total|amount\s*due|balance\s*due|total)/i;

    for(const w of words){
      const t = (w.text || w.word || "").trim();
      if(!t) continue;
      if(rx.test(t)){
        hits.push(w);
      }
    }
    if(!hits.length){ statusEl.className="err"; statusEl.textContent="Couldn‚Äôt find 'total' text. Try zoom/rotate/crop manually."; return; }

    // Build a region around the FIRST hit and extend to the right to include amount
    // Combine neighboring words on the same line to expand the box
    const lineY = hits[0].bbox?.y0 ?? hits[0].y0 ?? 0;
    const sameLine = words.filter(w=>{
      const y0 = w.bbox?.y0 ?? w.y0 ?? 0;
      const y1 = w.bbox?.y1 ?? w.y1 ?? 0;
      return Math.abs(((y0+y1)/2) - ((hits[0].bbox?.y0+hits[0].bbox?.y1)/2)) < 20;
    });

    const xs = sameLine.map(w=>w.bbox?.x0 ?? w.x0 ?? 0);
    const xe = sameLine.map(w=>w.bbox?.x1 ?? w.x1 ?? 0);
    const ys = sameLine.map(w=>w.bbox?.y0 ?? w.y0 ?? 0);
    const ye = sameLine.map(w=>w.bbox?.y1 ?? w.y1 ?? 0);

    let x0 = Math.min(...xs), x1 = Math.max(...xe);
    let y0 = Math.min(...ys), y1 = Math.max(...ye);

    // Expand region slightly and include a block to the right/down where numbers usually are
    const pad = 30;
    x0 = Math.max(0, x0 - pad);
    y0 = Math.max(0, y0 - pad);
    x1 = x1 + pad + 250; // extend to the right to catch amount column
    y1 = y1 + pad + 120; // extend downward a bit

    // Map back to canvas crop coords:
    // We built fullUrl via buildOcrDataURL() with upscale factor 2 and using fitScale mappings.
    // That function outputs a tightly cropped "upright" full image in OCR pixels (no manual crop).
    // Here, we assume a direct 1:1 between OCR image px and visual ‚Äúfit‚Äù inside the canvas when zoom=1.
    // To make it robust across zooms, we compute using the same mapping as drawPreview:
    const zoom = Number(Z.value);
    const imgW = (rotation%180===0) ? baseImage.width : baseImage.height;
    const imgH = (rotation%180===0) ? baseImage.height : baseImage.width;
    const fitScale = Math.min(canvas.width/imgW, canvas.height/imgH) * zoom;

    const drawW = Math.round(imgW*fitScale);
    const drawH = Math.round(imgH*fitScale);
    const dx = Math.round((canvas.width - drawW)/2);
    const dy = Math.round((canvas.height - drawH)/2);

    // Because buildOcrDataURL uses an upscale=2, divide bbox by 2 to map to original upright image px
    const upscale = 2;
    const bx = x0 / upscale, by = y0 / upscale, bw = (x1 - x0)/upscale, bh = (y1 - y0)/upscale;

    // Now map upright image px ‚Üí canvas coords
    const cx = dx + Math.round(bx * fitScale);
    const cy = dy + Math.round(by * fitScale);
    const cw = Math.round(bw * fitScale);
    const ch = Math.round(bh * fitScale);

    crop = { x: cx, y: cy, w: cw, h: ch };
    drawPreview();
    statusEl.className="ok"; statusEl.textContent="Totals region detected ‚Äî click Scan.";
  }catch(e){
    statusEl.className="err"; statusEl.textContent="Auto-detect failed: " + (e?.message || e);
  }
}

/* ---------- Actions ---------- */
qs("scanBtn").addEventListener("click", async ()=>{
  try{
    statusEl.className="muted"; statusEl.textContent="Preparing selection‚Ä¶";
    const dataUrl = await buildOcrDataURL();
    statusEl.textContent="Scanning locally‚Ä¶";
    const { text } = await ocrDataUrl(dataUrl);
    const out = extractFields(text);
    if(out.vendor) qs("vendor").value = out.vendor;
    if(out.date) qs("rdate").value = out.date;
    if(typeof out.total==="number") qs("total").value = to2(out.total);
    if(typeof out.tax==="number") qs("tax").value = to2(out.tax);
    updateSubtotalPreview();
    statusEl.className="ok"; statusEl.textContent="Scan complete ‚Äî review & save.";
  }catch(e){
    statusEl.className="err"; statusEl.textContent="Scan failed: " + (e?.message || e);
  }
});
qs("autoDetect").addEventListener("click", autoDetectTotals);

async function loadUnmatched(){
  const tbody=qs("unmatchedTable").querySelector("tbody");
  tbody.innerHTML=`<tr><td colspan="7">Loading‚Ä¶</td></tr>`;
  const {data,error}=await sb.from("v_unmatched_receipts")
    .select("receipt_date,vendor,total,tax,category,source,image_url,created_at")
    .order("created_at",{ascending:false}).limit(25);
  if(error){ tbody.innerHTML = `<tr><td colspan="7" class="err">${error.message}</td></tr>`; return; }
  if(!data?.length){ tbody.innerHTML = `<tr><td colspan="7" class="muted">All caught up‚Äîno unmatched receipts.</td></tr>`; return; }
  tbody.innerHTML = data.map(r=>{
    const tot = typeof r.total==="number" ? r.total.toFixed(2) : (r.total ?? "");
    const tax = typeof r.tax==="number" ? r.tax.toFixed(2)   : (r.tax ?? "");
    const img = r.image_url ? `<a href="${r.image_url}" target="_blank" class="chip">open</a>` : "";
    return `<tr><td>${r.receipt_date??""}</td><td>${r.vendor??""}</td><td class="right">$${tot}</td><td class="right">$${tax}</td><td>${r.category??""}</td><td>${r.source??""}</td><td>${img}</td></tr>`
  }).join("");
}
qs("refreshBtn").addEventListener("click",loadUnmatched);

qs("uploadBtn").addEventListener("click", async ()=>{
  msgEl.className="muted"; msgEl.textContent="Uploading‚Ä¶";
  const file=qs("fileInput").files?.[0];
  if(!file){ msgEl.className="err"; msgEl.textContent="Pick a file first."; return; }

  const path=`${Date.now()}-${file.name}`;
  const { error: upErr } = await sb.storage.from(BUCKET).upload(path, file, {
    contentType:file.type||"application/octet-stream", upsert:false
  });
  if(upErr){ msgEl.className="err"; msgEl.textContent="Storage error: "+upErr.message; return; }
  const { data: pub } = sb.storage.from(BUCKET).getPublicUrl(path);
  const publicUrl = pub?.publicUrl;

  const payload = {
    image_url: publicUrl,
    vendor: qs("vendor").value || null,
    receipt_date: qs("rdate").value || null,
    total: qs("total").value ? Number(qs("total").value) : null,
    tax: qs("tax").value ? Number(qs("tax").value) : 0,
    category: qs("category").value || null,
    source: qs("source").value || null,
    notes: qs("notes").value || null
  };
  const { error } = await sb.from("receipts").insert([payload]);
  if(error){ msgEl.className="err"; msgEl.textContent="DB error: " + error.message; return; }

  msgEl.className="ok"; msgEl.textContent="Uploaded & saved.";
  qs("fileInput").value="";
  await loadUnmatched();
});

qs("btnApply").addEventListener("click", async ()=>{
  autoMsg.className="muted"; autoMsg.textContent="Applying rules‚Ä¶";
  const { error } = await sb.rpc("apply_rules");
  if(error){ autoMsg.className="err"; autoMsg.textContent=error.message; return; }
  autoMsg.className="ok"; autoMsg.textContent="Rules applied.";
  loadUnmatched();
});
qs("btnMatch").addEventListener("click", async ()=>{
  autoMsg.className="muted"; autoMsg.textContent="Matching‚Ä¶";
  const fn = qs("matchMode").value === "fuzzy" ? "match_now_fuzzy" : "match_now";
  const { error } = await sb.rpc(fn);
  if(error){ autoMsg.className="err"; autoMsg.textContent=error.message; return; }
  autoMsg.className="ok"; autoMsg.textContent="Matching complete.";
  loadUnmatched();
});
qs("exportBtn").addEventListener("click", async ()=>{
  autoMsg.className="muted"; autoMsg.textContent="Building CSV‚Ä¶";
  const { data, error } = await sb.from("v_accountant_export_receipts").select("*").order("receipt_date",{ascending:true});
  if(error){ autoMsg.className="err"; autoMsg.textContent = error.message; return; }
  if(!data?.length){ autoMsg.textContent="No data."; return; }
  const cols=["receipt_date","vendor","category","source","subtotal","tax","total","notes","image_url"];
  const header=cols.join(",");
  const rows=data.map(r=>cols.map(k=>{
    const v=r[k]??""; const s=String(v);
    return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;
  }).join(","));
  const csv=[header,...rows].join("\n");
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const url=URL.createObjectURL(blob); const a=document.createElement("a");
  a.href=url; a.download=`accountant_export_${new Date().toISOString().slice(0,10)}.csv`;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  autoMsg.className="ok"; autoMsg.textContent="CSV downloaded.";
});

/* init */
loadUnmatched();
</script>
</body>
</html>
