<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kosmos Bookkeeping</title>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.20.2/dist/xlsx.full.min.js"></script>
  <style>
    :root{ --bg:#fafafa; --card:#fff; --border:#e5e7eb; --muted:#6b7280; --ok:#0a7a33; --err:#b00020; --ink:#111; --btn:#111; --btnH:#333; }
    *{ box-sizing:border-box; }
    body{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:24px; background:var(--bg); color:var(--ink); }
    h1{ font-size:1.6rem; margin:0 0 .75rem; }
    h3{ margin:0 0 .25rem; }
    .wrap{ display:grid; grid-template-columns:520px 1fr; gap:24px; align-items:start; }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    label{ display:block; margin-top:.7rem; font-weight:600; }
    input{ width:100%; padding:.6rem .7rem; border:1px solid #cfcfcf; border-radius:10px; margin-top:.35rem; background:#fff; }
    input[readonly]{ background:#f7f7f7; }
    small.muted{ color:var(--muted); display:block; margin-top:.25rem; }
    .muted{ color:var(--muted); } .ok{ color:var(--ok); } .err{ color:var(--err); }
    button{ padding:.6rem 1rem; border-radius:10px; border:1px solid #bbb; background:var(--btn); color:#fff; cursor:pointer; }
    button:hover{ background:var(--btnH); }
    .secondary{ background:#f7f7f7; color:#111; border-color:#d0d0d0; }
    .secondary:hover{ background:#eee; }
    .rowbtns{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
    table{ width:100%; border-collapse:collapse; font-size:14px; }
    th, td{ padding:8px 10px; border-bottom:1px solid var(--border); text-align:left; }
    th{ background:#f6f7f8; position:sticky; top:0; z-index:1; }
    .right{ text-align:right; }
    .chip{ font-size:12px; background:#eef2ff; border:1px solid #c7d2fe; padding:2px 6px; border-radius:999px; }
    .dropdown{ position:relative; display:inline-block; } .dropdown-btn{ display:inline-flex; align-items:center; gap:6px; }
    .caret{ width:0; height:0; border-left:5px solid transparent; border-right:5px solid transparent; border-top:5px solid currentColor; }
    .menu{ position:absolute; top:100%; left:0; background:#fff; border:1px solid var(--border); border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,.07); padding:6px; margin-top:6px; min-width:220px; display:none; z-index:10; }
    .menu.open{ display:block; } .menu button{ width:100%; text-align:left; background:#fff; color:#111; border:0; padding:.55rem .7rem; border-radius:8px; }
    .menu button:hover{ background:#f3f4f6; }
    @media (max-width:1100px){ .wrap{ grid-template-columns:1fr; } }
    select{ padding:.5rem; border:1px solid #ccc; border-radius:8px; }
  </style>
</head>
<body>
  <h1>Kosmos Bookkeeping</h1>
  <div class="wrap">
    <div>
      <div class="card">
        <p id="status">Connecting…</p>
        <p><strong>Receipts in database:</strong> <span id="receiptCount">—</span></p>
      </div>
      <div class="card" style="margin-top:16px;">
        <h3>Upload a receipt (manual-only)</h3>
        <small class="muted">Uploads image → saves to <code>receipts-warm</code> → inserts row in <code>public.receipts</code>.</small>
        <div class="row"><input type="file" id="fileInput" accept="image/*,.pdf" /></div>
        <label>Vendor<input id="vendor" list="vendorList" placeholder="Start typing… e.g., No Frills, Sysco, Costco"/><datalist id="vendorList"></datalist><small class="muted">Suggestions come from your existing receipts.</small></label>
        <label>Date<input id="rdate" type="date"/></label>
        <label>Total<input id="total" type="number" step="0.01"/></label>
        <label>Tax<input id="tax" type="number" step="0.01"/></label>
        <label>Subtotal (auto)<input id="subtotal" type="number" step="0.01" readonly/></label>
        <label>Category<input id="category" list="categoryList" placeholder="Pick or type a category…"/><datalist id="categoryList"></datalist><small class="muted">Master list; you can still type a new one.</small></label>
        <label>Source<input id="source" list="sourceList" placeholder="e.g., CIBC Chequing, TD Visa, Cash…"/><datalist id="sourceList"></datalist><small class="muted">Suggestions come from your existing receipts.</small></label>
        <label>Notes<input id="notes" placeholder="optional"/></label>
        <button id="uploadBtn">Upload & Save</button><p id="msg" class="muted"></p>
      </div>
      <div class="card" style="margin-top:16px;">
        <h3>Automation</h3>
        <small class="muted">Run your Supabase bookkeeping functions right from here.</small>
        <div class="rowbtns">
          <button id="btnApply" class="secondary" title="Auto-categorize receipts">Apply Rules</button>
          <select id="matchMode" aria-label="Match mode"><option value="strict" selected>Strict match</option><option value="fuzzy">Fuzzy match</option></select>
          <button id="btnMatch" class="secondary" title="Match receipts ↔ bank txns">Match</button>
          <div class="dropdown">
            <button id="exportBtn" class="dropdown-btn secondary" type="button" aria-haspopup="true" aria-expanded="false">Export <span class="caret"></span></button>
            <div id="exportMenu" class="menu" role="menu" aria-label="Export Options">
              <button id="optCsv" role="menuitem">CSV (Accountant-ready)</button>
              <button id="optXlsx" role="menuitem">Excel (.xlsx)</button>
            </div>
          </div>
        </div>
        <p id="autoMsg" class="muted"></p>
      </div>
      <div class="card" style="margin-top:16px;">
        <h3>Import Bank Statement (CSV)</h3>
        <small class="muted">Drag-drop or choose a .CSV file; rows go into <code>public.transactions</code>.</small>
        <input type="file" id="bankCsvInput" accept=".csv" style="margin-top:8px;">
        <div class="rowbtns"><button id="importCsvBtn">Import CSV</button></div>
        <p id="csvMsg" class="muted"></p>
      </div>
    </div>
    <div class="card">
      <h3>Unmatched receipts</h3>
      <small class="muted">Newest first • From view <code>v_unmatched_receipts</code> • Last 25</small>
      <div style="max-height: 540px; overflow:auto; margin-top:8px;">
        <table id="unmatchedTable"><thead><tr><th>Date</th><th>Vendor</th><th class="right">Total</th><th class="right">Tax</th><th>Category</th><th>Source</th><th>Image</th></tr></thead><tbody></tbody></table>
      </div>
      <div style="margin-top:8px;"><button id="refreshBtn" class="secondary" title="Reload list">Refresh</button></div>
    </div>
  </div>
  <script>
    const SUPABASE_URL = "https://advihqhjjlxumgdlbwui.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFkdmlocWhqamx4dW1nZGxid3VpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwMTg0MzIsImV4cCI6MjA3NjU5NDQzMn0.kVlaPQg2_o9DGJYv22Dgca7veok4drF6kgLPy2wPBeY";
    const BUCKET = "receipts-warm";
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const qs = id => document.getElementById(id);
    const statusEl = qs("status"), msgEl = qs("msg"), autoMsg = qs("autoMsg"), countEl = qs("receiptCount");
    function uniqueCaseInsensitive(values){ const seen = new Map(); for(const v of values){ if(!v) continue; const s=String(v).trim(); if(!s) continue; const k=s.toLowerCase(); if(!seen.has(k)) seen.set(k,s); } return Array.from(seen.values()).sort((a,b)=>a.localeCompare(b)); }
    function fillDatalist(id, arr){ qs(id).innerHTML = arr.map(v=>`<option value="${String(v).replaceAll('"','&quot;')}"></option>`).join(""); }
    async function refreshCount(){ const {count,error} = await sb.from("receipts").select("*",{count:"exact",head:true}); if(!error) countEl.textContent = count ?? 0; }
    function updateSubtotalPreview(){ const t = parseFloat(qs("total").value)||0; const x = parseFloat(qs("tax").value)||0; qs("subtotal").value = (t - x).toFixed(2); }
    qs("total").addEventListener("input", updateSubtotalPreview); qs("tax").addEventListener("input", updateSubtotalPreview);
    const PRESET_CATEGORIES = ["Food","Alcohol","Restaurant Supplies","Building Supplies","Tools & Equipment","Cleaning Supplies","General Supplies","Gas","Delivery Fees","Utilities","Repairs & Maintenance","Income","Office Supplies","Software","Bank Fees"];
    async function loadDynamicLists(){ const {data, error} = await sb.from("receipts").select("vendor, source, category").limit(5000); let vendors=[], sources=[], dbCats=[]; if(!error && Array.isArray(data)){ vendors = uniqueCaseInsensitive(data.map(r=>r.vendor)); sources = uniqueCaseInsensitive(data.map(r=>r.source)); dbCats  = uniqueCaseInsensitive(data.map(r=>r.category)); } fillDatalist("vendorList", vendors); fillDatalist("sourceList", sources); fillDatalist("categoryList", uniqueCaseInsensitive([...PRESET_CATEGORIES, ...dbCats])); }
    async function loadUnmatched(){ const tbody = qs("unmatchedTable").querySelector("tbody"); tbody.innerHTML = `<tr><td colspan="7">Loading…</td></tr>`; const {data, error} = await sb.from("v_unmatched_receipts").select("id, receipt_date, vendor, total, tax, category, source, image_url, created_at").order("created_at", {ascending:false}).limit(25); if(error){ tbody.innerHTML = `<tr><td colspan="7" class="err">Error: ${error.message}</td></tr>`; return; } if(!data?.length){ tbody.innerHTML = `<tr><td colspan="7" class="muted">All caught up—no unmatched receipts.</td></tr>`; return; } const rows = data.map(r=>{ const total = (typeof r.total === "number") ? r.total.toFixed(2) : (r.total ?? ""); const tax   = (typeof r.tax   === "number") ? r.tax.toFixed(2)   : (r.tax ?? ""); const img = r.image_url ? `<a href="${r.image_url}" target="_blank" class="chip">open</a>` : ""; return `<tr><td>${r.receipt_date ?? ""}</td><td>${r.vendor ?? ""}</td><td class="right">$${total}</td><td class="right">$${tax}</td><td>${r.category ?? ""}</td><td>${r.source ?? ""}</td><td>${img}</td></tr>`; }).join(""); tbody.innerHTML = rows; }
    async function init(){ await refreshCount(); await loadDynamicLists(); await loadUnmatched(); statusEl.textContent = "Connected."; }
    qs("uploadBtn").addEventListener("click", async ()=>{ msgEl.className="muted"; msgEl.textContent="Uploading…"; const file = qs("fileInput").files?.[0]; if(!file){ msgEl.className="err"; msgEl.textContent="Pick a file first."; return; } const objectPath = `${Date.now()}-${file.name}`; const {error:upErr} = await sb.storage.from(BUCKET).upload(objectPath, file, { contentType:file.type || "application/octet-stream", upsert:false }); if(upErr){ msgEl.className="err"; msgEl.textContent="Storage error: "+upErr.message; return; } const {data:pub} = sb.storage.from(BUCKET).getPublicUrl(objectPath); const publicUrl = pub?.publicUrl; const vendor = qs("vendor").value || null; const rdate  = qs("rdate").value  || null; const total  = qs("total").value ? Number(qs("total").value) : null; const tax    = qs("tax").value   ? Number(qs("tax").value)   : 0.00; const category = qs("category").value || null; const source   = qs("source").value   || null; const notes    = qs("notes").value    || null; const {error:insErr} = await sb.from("receipts").insert([{ image_url: publicUrl, vendor, receipt_date:rdate, total, tax, category, source, notes, entered_by: null }]); if(insErr){ msgEl.className="err"; msgEl.textContent="DB error: "+insErr.message; return; } msgEl.className="ok"; msgEl.textContent="Uploaded & saved successfully."; qs("fileInput").value=""; await refreshCount(); await loadDynamicLists(); await loadUnmatched(); });
    qs("btnApply").addEventListener("click", async ()=>{ autoMsg.className="muted"; autoMsg.textContent="Applying rules…"; const { data, error } = await sb.rpc("apply_rules"); if(error){ autoMsg.className="err"; autoMsg.textContent="Error: "+error.message; return; } const n = (typeof data === "number") ? data : 0; autoMsg.className="ok"; autoMsg.textContent=`Rules applied. Updated ${n} row(s).`; await loadUnmatched(); });
    qs("btnMatch").addEventListener("click", async ()=>{ autoMsg.className="muted"; autoMsg.textContent="Matching…"; const mode = qs("matchMode").value; const fn = mode === "fuzzy" ? "match_now_fuzzy" : "match_now"; const { data, error } = await sb.rpc(fn); if(error){ autoMsg.className="err"; autoMsg.textContent=`Error (${mode}): ${error.message}`; return; } const n = (typeof data === "number") ? data : 0; autoMsg.className="ok"; autoMsg.textContent=`Matching complete (${mode}). Inserted ${n} match(es).`; await loadUnmatched(); });
    const EXPORT_COLUMNS = [{ key:"receipt_date", label:"Date" },{ key:"vendor", label:"Vendor" },{ key:"category", label:"Category" },{ key:"source", label:"Source" },{ key:"subtotal", label:"Subtotal" },{ key:"tax", label:"Tax" },{ key:"total", label:"Total" },{ key:"notes", label:"Notes" },{ key:"image_url", label:"Image URL" },{ key:"id", label:"Receipt ID" }];
    function fmtDateISO(d){ if(!d) return ""; const s=String(d).slice(0,10); return /^\d{4}-\d{2}-\d{2}$/.test(s)?s:s; }
    function to2(n){ if(n===null || n===undefined || n==="") return ""; const v=Number(n); return Number.isNaN(v)?"":v.toFixed(2); }
    function escCSV(v){ if(v===null || v===undefined) return ""; const s=String(v); return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; }
    async function fetchExportData(){ const {data, error} = await sb.from("v_accountant_export_receipts").select("*").order("receipt_date",{ascending:true}); if(error) throw new Error(error.message); return data||[]; }
    async function exportCSV(){ autoMsg.className="muted"; autoMsg.textContent="Building CSV…"; let data; try{ data = await fetchExportData(); } catch(e){ autoMsg.className="err"; autoMsg.textContent=e.message; return; } if(!data.length){ autoMsg.className="muted"; autoMsg.textContent="No data to export."; return; } const header = EXPORT_COLUMNS.map(c=>c.label); const rows = data.map(r => EXPORT_COLUMNS.map(c=>{ let val = r[c.key]; if(c.key==="receipt_date") return escCSV(fmtDateISO(val)); if(["total","tax","subtotal"].includes(c.key)) return escCSV(to2(val)); return escCSV(val??""); }).join(",")); const sum = k => data.reduce((a,r)=>a+(Number(r[k])||0),0); const totalsRow = EXPORT_COLUMNS.map(c=>{ if(c.key==="receipt_date") return escCSV("Totals"); if(c.key==="subtotal") return escCSV(to2(sum("subtotal"))); if(c.key==="tax")      return escCSV(to2(sum("tax"))); if(c.key==="total")    return escCSV(to2(sum("total"))); return ""; }).join(","); const csv = [header.join(","), ...rows, totalsRow].join("\n"); const blob = new Blob([csv], {type:"text/csv;charset=utf-8"}); const url = URL.createObjectURL(blob); const a = document.createElement("a"); const today = new Date().toISOString().slice(0,10); a.href = url; a.download = `accountant_export_${today}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); autoMsg.className="ok"; autoMsg.textContent="CSV downloaded."; }
    async function exportXLSX(){ autoMsg.className="muted"; autoMsg.textContent="Building Excel…"; let data; try{ data = await fetchExportData(); } catch(e){ autoMsg.className="err"; autoMsg.textContent=e.message; return; } if(!data.length){ autoMsg.className="muted"; autoMsg.textContent="No data to export."; return; } const headers = EXPORT_COLUMNS.map(c=>c.label); const body = data.map(r => EXPORT_COLUMNS.map(c=>{ if(c.key==="receipt_date") return fmtDateISO(r[c.key]); if(["total","tax","subtotal"].includes(c.key)) return Number(r[c.key] ?? 0); return r[c.key] ?? ""; })); const totals = { subtotal: data.reduce((a,r)=>a+(Number(r.subtotal)||0),0), tax:      data.reduce((a,r)=>a+(Number(r.tax)||0),0), total:    data.reduce((a,r)=>a+(Number(r.total)||0),0), }; const totalsRow = EXPORT_COLUMNS.map(c=>{ if(c.key==="receipt_date") return "Totals"; if(c.key==="subtotal") return totals.subtotal; if(c.key==="tax")      return totals.tax; if(c.key==="total")    return totals.total; return ""; }); const wsData = [headers, ...body, totalsRow]; const ws = XLSX.utils.aoa_to_sheet(wsData); const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "Receipts Export"); const today = new Date().toISOString().slice(0,10); XLSX.writeFile(wb, `accountant_export_${today}.xlsx`); autoMsg.className="ok"; autoMsg.textContent="Excel downloaded."; }
    const exportBtn  = qs("exportBtn"), exportMenu = qs("exportMenu"); exportBtn.addEventListener("click", ()=>{ const open = exportMenu.classList.toggle("open"); exportBtn.setAttribute("aria-expanded", open ? "true" : "false"); }); document.addEventListener("click", (e)=>{ if(!exportMenu.contains(e.target) && !exportBtn.contains(e.target)){ exportMenu.classList.remove("open"); exportBtn.setAttribute("aria-expanded","false"); } }); qs("optCsv").addEventListener("click", ()=>{ exportMenu.classList.remove("open"); exportCSV(); }); qs("optXlsx").addEventListener("click", ()=>{ exportMenu.classList.remove("open"); exportXLSX(); }); qs("refreshBtn").addEventListener("click", loadUnmatched);
    qs("importCsvBtn").addEventListener("click", async ()=>{
      const set = (cls, msg) => { qs("csvMsg").className = cls; qs("csvMsg").textContent = msg; console.log("[CSV]", msg); };
      try {
        const file = qs("bankCsvInput").files?.[0];
        if(!file){ set("err","Pick a CSV first."); return; }
        set("muted","Reading CSV…");
        let rows = null;
        try {
          if(typeof XLSX === "undefined") throw new Error("SheetJS not loaded");
          const ab = await file.arrayBuffer();
          const wb = XLSX.read(ab, { type: "array" });
          const sheet = wb.Sheets[wb.SheetNames?.[0]];
          if(!sheet) throw new Error("No sheet found.");
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: "" });
          if(!rows?.length) throw new Error("Parsed zero rows.");
        } catch (e) {
          set("muted","Reading CSV (fallback) …");
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line=>{
            const out = []; let cur = "", inQ = false;
            for(let i=0;i<line.length;i++){
              const ch = line[i];
              if(ch === '"'){ inQ = !inQ; continue; }
              if(ch === "," && !inQ){ out.push(cur); cur=""; continue; }
              cur += ch;
            }
            out.push(cur);
            return out.map(c=>c.trim().replace(/^"(.*)"$/,"$1"));
          }).filter(r=>r.some(c=>String(c).trim().length>0));
          if(!rows?.length){ throw new Error("Fallback parsed zero rows."); }
        }
        const isLikelyDate = (v) => { if(v instanceof Date) return true; const s = String(v).trim(); return /^\d{4}[-\/]\d{2}[-\/]\d{2}$/.test(s) || /^\d{2}[-\/]\d{2}[-\/]\d{4}$/.test(s); };
        const first = rows[0] || [];
        const headerLooksLikeData = isLikelyDate(first[0]) && String(first[1]||"").length > 0;
        let header = []; let dataRows = [];
        if(headerLooksLikeData){ header = ["date","description","debit","credit"]; dataRows = rows; }
        else { header = first.map(h => String(h).trim().toLowerCase()); dataRows = rows.slice(1); }
        const idx = (name) => header.findIndex(h => h === name);
        const findCol = (regex) => header.findIndex(h => regex.test(h));
        let iDate   = idx("date");             if(iDate   < 0) iDate   = findCol(/date/);
        let iDesc   = idx("description");      if(iDesc   < 0) iDesc   = findCol(/desc|vendor|memo|details?/);
        let iAmount = idx("amount");           if(iAmount < 0) iAmount = findCol(/amount/);
        let iDebit  = idx("debit");            if(iDebit  < 0) iDebit  = findCol(/debit|withdrawal/);
        let iCredit = idx("credit");           if(iCredit < 0) iCredit = findCol(/credit|deposit/);
        let iType   = idx("type");             if(iType   < 0) iType   = findCol(/type/);
        if(headerLooksLikeData){ iDate = 0; iDesc = 1; iDebit = 2; iCredit = 3; }
        if(iDate < 0 || iDesc < 0 || (iAmount < 0 && iDebit < 0 && iCredit < 0)){ console.error("[CSV] Header:", header); set("err","Missing key columns (need date, description, and amount or debit/credit)."); return; }
        const toNum = (v) => { if(v == null) return 0; if(typeof v === "number") return v; let s = String(v).trim(); if(!s) return 0; const neg = /^\(.*\)$/.test(s); s = s.replace(/[(),$]/g,"").replace(/\s+/g,""); let n = Number(s.replace(/[^0-9.-]/g,"")); if(Number.isNaN(n)) n = 0; return neg ? -Math.abs(n) : n; };
        const txns = [];
        for(let r = 0; r < dataRows.length; r++){
          const row = dataRows[r] || [];
          const rawDate = row[iDate]; if(!rawDate) continue;
          let isoDate = "";
          if(rawDate instanceof Date) { isoDate = rawDate.toISOString().slice(0,10); }
          else { const s = String(rawDate).trim(); if(/^\d{2}\/\d{2}\/\d{4}$/.test(s)){ const [dd,mm,yyyy] = s.split("/"); isoDate = `${yyyy}-${mm}-${dd}`; } else { const d = new Date(s); if(!isNaN(d.getTime())) isoDate = d.toISOString().slice(0,10); } }
          if(!isoDate) continue;
          const desc = String(row[iDesc] ?? "").trim(); if(!desc) continue;
          let amount = 0, direction = "debit";
          if(iAmount >= 0){ const a = toNum(row[iAmount]); if(a === 0) continue; direction = a < 0 ? "debit" : "credit"; amount = Math.abs(a); }
          else { const d = iDebit  >= 0 ? toNum(row[iDebit])  : 0; const c = iCredit >= 0 ? toNum(row[iCredit]) : 0; if(d === 0 && c === 0) continue; if(d !== 0){ amount = Math.abs(d); direction = "debit"; } else { amount = Math.abs(c); direction = "credit"; } }
          txns.push({ org_id: null, account_id: null, txn_date: isoDate, post_date: isoDate, description: desc, vendor_clean: desc, amount, direction, currency: "CAD", imported_from: file.name, csv_row: (headerLooksLikeData ? r+1 : r+2) });
        }
        if(!txns.length){ set("err","No valid rows found (after parsing)."); return; }
        set("muted",`Uploading ${txns.length} transactions…`);
        const { error } = await sb.from("transactions").insert(txns);
        if(error){ set("err","DB error: "+error.message); return; }
        set("ok",`Imported ${txns.length} transactions from ${file.name}. Matching now…`);
        const { data: matched, error: mErr } = await sb.rpc("match_now");
        if(mErr){ set("err","Imported, but matching failed: "+mErr.message); return; }
        set("ok",`Imported ${txns.length} transactions. Auto-matched ${matched ?? 0} receipt(s).`);
      } catch (e) { console.error(e); qs("csvMsg").className = "err"; qs("csvMsg").textContent = "Importer crashed: " + (e?.message || e); }
    });
    init();
  </script>
</body>
</html>
