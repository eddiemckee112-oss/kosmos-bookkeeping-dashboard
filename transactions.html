<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Kosmos Bookkeeping ‚Äî Transactions</title>
  <link rel="stylesheet" href="style.css"/>
  <style>
    /* Page tweaks */
    .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{padding:4px 10px;border:1px solid var(--border);border-radius:999px;background:#fff}
    .status-btn{font-size:.8rem;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff}
    .status-btn.ok{background:#eef8f1;border-color:#cfe9d7;color:var(--ok)}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.18);display:none;align-items:flex-start;justify-content:center;padding:40px 12px;z-index:50}
    .modal{background:#fff;width:min(1100px,100%);max-height:85vh;overflow:auto;border:1px solid var(--border);border-radius:16px;padding:16px 16px 18px}
    .right{text-align:right} .muted{color:var(--muted)} .ok{color:var(--ok)} .err{color:var(--err)}
    .small{font-size:.85rem}
  </style>
</head>
<body>
  <!-- Header / Nav -->
  <header>
    <h1>Kosmos Bookkeeping</h1>
    <nav>
      <a href="index.html">Dashboard</a>
      <a href="receipts.html">Receipts</a>
      <a class="active" href="transactions.html">Transactions</a>
      <a href="reports.html">Reports</a>
    </nav>
  </header>

  <main class="container">
    <h2>üí≥ Transactions</h2>
    <p class="muted">Filter, import, categorize, attach receipts, create vendor rules, and use bulk actions for speed.</p>

    <!-- Filters / Actions -->
    <div class="card" style="margin-bottom:14px;">
      <div class="toolbar">
        <label>Date Range:</label>
        <input id="fromDate" type="date"/>
        <span>‚Äì</span>
        <input id="toDate" type="date"/>

        <select id="typeFilter">
          <option value="all">All</option>
          <option value="debit">Debits only</option>
          <option value="credit">Credits only</option>
          <option value="matched">Matched only</option>
          <option value="unmatched">Unmatched only</option>
          <option value="uncategorized">Uncategorized</option>
          <option value="no_source">No Source</option>
          <option value="duplicates">Possible Duplicates</option>
        </select>

        <button id="applyBtn">Apply</button>

        <input id="quickSearch" placeholder="Search description/category/source‚Ä¶" style="flex:1;min-width:220px"/>

        <button id="importBtn" class="ghost">üì• Import CSV</button>
        <button id="backfillBtn" class="ghost">‚ü≥ Backfill Sources</button>
        <button id="exportBtn" class="ghost">‚¨áÔ∏è Export CSV</button>
      </div>

      <div class="row" style="gap:10px;margin-top:10px;">
        <span class="pill">Unmatched: <b id="chipUnmatched">‚Äî</b></span>
        <span class="pill">Uncategorized: <b id="chipUncat">‚Äî</b></span>
        <span class="pill">No Source: <b id="chipNoSource">‚Äî</b></span>
        <span class="pill">Duplicates: <b id="chipDupes">‚Äî</b></span>
      </div>
    </div>

    <!-- Totals -->
    <div class="card" style="margin-bottom:14px;">
      <div>Total Transactions: <b id="totalRows">‚Äî</b></div>
      <div>Debits: <b id="totalDebits">$0.00</b></div>
      <div>Credits: <b id="totalCredits">$0.00</b></div>
      <div>Net: <b id="totalNet">$0.00</b></div>
      <small class="muted">Numbers reflect the current filter.</small>
    </div>

    <!-- Table -->
    <div class="card">
      <table id="txTable">
        <thead>
          <tr>
            <th style="width:26px"></th>
            <th>Date</th>
            <th>Description</th>
            <th class="right">Amount</th>
            <th>Type</th>
            <th>Status</th>
            <th>Category</th>
            <th>Source</th>
          </tr>
        </thead>
        <tbody id="txBody"></tbody>
      </table>
      <div class="muted" id="rowsCount" style="margin-top:8px">Rows: 0</div>
    </div>
  </main>

  <!-- ===== Importer Modal (FULL) ===== -->
  <div id="impBackdrop" class="modal-backdrop">
    <div class="modal">
      <h3>Import Transactions (CSV)</h3>
      <p class="note muted small">
        Auto-detects: <b>Date, Description, Amount</b> or <b>Date, Description, Debit, Credit</b>.  
        Optional columns like <b>Type</b> (debit/credit) or <b>Source</b> are recognized. Handles $ signs, commas, and (parentheses) negatives.
      </p>

      <div class="card" style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
        <input id="csvFile" type="file" accept=".csv,text/csv"/>
        <button id="closeImport" class="ghost">Close</button>
      </div>

      <p id="impStatus" class="muted small" style="margin-top:10px;">Select a CSV to begin.</p>
      <div class="kpill small" id="countPill" style="display:inline-block;margin-top:6px;">
        Parsed ‚Äî ¬∑ Valid ‚Äî ¬∑ Skipped ‚Äî ¬∑ Debits ‚Äî ¬∑ Credits ‚Äî
      </div>

      <div id="impPreview" class="card" style="margin-top:12px;display:none;">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
          <h4 style="margin:0">Preview (first 20 rows)</h4>
        </div>
        <table style="width:100%;border-collapse:collapse;">
          <thead>
            <tr><th>Date</th><th>Description</th><th class="right">Amount</th><th>Direction</th><th>Source</th></tr>
          </thead>
          <tbody id="prevBody"><tr><td colspan="5" class="muted">No rows yet</td></tr></tbody>
        </table>
      </div>

      <div class="row" style="justify-content:flex-end;margin-top:12px">
        <button id="importGo" class="ghost">Import</button>
      </div>
    </div>
  </div>

  <!-- ===== Scripts ===== -->
  <script>
    const $ = id => document.getElementById(id);
    const esc = s => String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    const money = n => (n==null?0:n).toLocaleString(undefined,{style:"currency",currency:"CAD"});

    // Load transactions
    async function loadTransactions(){
      const from = $("fromDate").value || null;
      const to   = $("toDate").value || null;
      const q    = $("quickSearch").value.trim().toLowerCase();
      const type = $("typeFilter").value;

      let query = sb.from("transactions").select(`
        id, txn_date, description, amount, direction, category, source_account_name,
        created_at, matches:matches(id, transaction_id, receipt_id)
      `);

      if (from) query = query.gte("txn_date", from);
      if (to)   query = query.lte("txn_date", to);
      if (type === "debit")  query = query.eq("direction","debit");
      if (type === "credit") query = query.eq("direction","credit");

      query = query.order("txn_date",{ascending:false});

      const { data, error } = await query;
      if (error){ alert(error.message); return; }

      let rows = data || [];
      if (type === "matched")   rows = rows.filter(r => r.matches && r.matches.length);
      if (type === "unmatched") rows = rows.filter(r => !r.matches || r.matches.length===0);
      if (type === "uncategorized") rows = rows.filter(r => !r.category);
      if (type === "no_source")     rows = rows.filter(r => !r.source_account_name);
      if (type === "duplicates")    rows = findDuplicates(rows);

      if (q) rows = rows.filter(r =>
        (r.description||"").toLowerCase().includes(q) ||
        (r.source_account_name||"").toLowerCase().includes(q) ||
        (r.category||"").toLowerCase().includes(q)
      );

      // Totals
      const d = rows.filter(r=>r.direction==='debit').reduce((s,r)=>s+(+r.amount||0),0);
      const c = rows.filter(r=>r.direction==='credit').reduce((s,r)=>s+(+r.amount||0),0);
      $("totalRows").textContent   = rows.length;
      $("totalDebits").textContent = money(d);
      $("totalCredits").textContent= money(c);
      $("totalNet").textContent    = money(c-d);

      $("chipUnmatched").textContent = rows.filter(r => !r.matches || r.matches.length===0).length;
      $("chipUncat").textContent     = rows.filter(r => !r.category).length;
      $("chipNoSource").textContent  = rows.filter(r => !r.source_account_name).length;
      $("chipDupes").textContent     = findDuplicates(rows).length;

      // Render table
      $("txBody").innerHTML = rows.map(r=>{
        const statusOk = r.matches && r.matches.length;
        return `<tr>
          <td><input type="checkbox" data-id="${esc(r.id)}"/></td>
          <td>${esc(r.txn_date||"")}</td>
          <td>${esc(r.description||"")}</td>
          <td class="right">${money(r.amount)}</td>
          <td>${esc(r.direction||"")}</td>
          <td><button class="status-btn ${statusOk?'ok':'ghost'}">${statusOk?'Matched':'Unmatched'}</button></td>
          <td>${esc(r.category||"")}</td>
          <td>${esc(r.source_account_name||"")}</td>
        </tr>`;
      }).join("");
      $("rowsCount").textContent = `Rows: ${rows.length}`;
    }

    function findDuplicates(rows){
      const key = r => `${(r.txn_date||"").slice(0,10)}|${(r.amount||0)}|${(r.description||"").toLowerCase().replace(/\s+/g,' ').trim().slice(0,64)}`;
      const map = new Map();
      rows.forEach(r => map.set(key(r), (map.get(key(r))||0)+1));
      return rows.filter(r => map.get(key(r))>1);
    }

    $("applyBtn").addEventListener("click", loadTransactions);
    $("quickSearch").addEventListener("input", ()=>{ clearTimeout(window.__qsT); window.__qsT=setTimeout(loadTransactions,150); });

    $("backfillBtn").addEventListener("click", async ()=>{
      if (!sb?.rpc){ alert("Supabase client not found."); return; }
      const { error } = await sb.rpc("backfill_sources_simple"); // optional RPC you may have
      if (error) alert(error.message); else loadTransactions();
    });

    $("exportBtn").addEventListener("click", exportCSV);

    // ------- Importer (auto-detect Amount OR Debit/Credit) -------
    const CREDIT_RX = [/\bCREDIT\b/i,/DEPOSIT/i,/REFUND/i,/REVERSAL/i,/PAYOUT/i,/INTEREST/i,/TRANSFER FROM/i,/PAYMENT RECEIVED/i,/E[ -]?TRANSFER.*(RECEIVED|AUTO DEPOSIT)/i,/SQUARE CANADA INC/i,/STRIPE/i,/PAYPAL/i];
    const DEBIT_RX  = [/PRE[ -]?AUTH[ -]?DEBIT/i,/PURCHASE/i,/\bPOS\b/i,/INTERAC/i,/WITHDRAWAL/i,/BILL PAYMENT/i,/PAYMENT(?! RECEIVED)/i,/E[ -]?TRANSFER(?!.*(RECEIVED|AUTO DEPOSIT))/i];

    $("importBtn").addEventListener("click", ()=>{ openImporter(); });
    $("closeImport").addEventListener("click", ()=>{ $("impBackdrop").style.display="none"; });

    function openImporter(){
      $("impStatus").className="muted small";
      $("impStatus").textContent="Select a CSV to begin.";
      $("countPill").textContent="Parsed ‚Äî ¬∑ Valid ‚Äî ¬∑ Skipped ‚Äî ¬∑ Debits ‚Äî ¬∑ Credits ‚Äî";
      $("prevBody").innerHTML=`<tr><td colspan="5" class="muted">No rows yet</td></tr>`;
      $("impPreview").style.display="none";
      $("csvFile").value="";
      $("impBackdrop").style.display="flex";
      __valid=[]; __skipped=[]; __mode='A';
    }

    // CSV utils
    function detectDelimiterBlock(sample){
      const c=(sample.match(/,/g)||[]).length, s=(sample.match(/;/g)||[]).length, t=(sample.match(/\t/g)||[]).length;
      if(Math.max(c,s,t)===s) return ";"; if(Math.max(c,s,t)===t) return "\t"; return ",";
    }
    function parseLine(line, delim){
      const out=[]; let cur='', q=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch==='"'){ if(q && line[i+1]==='"'){cur+='"';i++;} else q=!q; }
        else if(ch===delim && !q){ out.push(cur); cur=''; }
        else cur+=ch;
      }
      out.push(cur);
      return out.map(x=>x.trim());
    }
    function parseCSV(text){
      const firstBlock = text.split(/\r?\n/).slice(0,8).join("\n");
      const delim = detectDelimiterBlock(firstBlock);
      const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
      const rows = [];
      for(const l of lines){
        if(l.trim()===""){ rows.push(null); continue; }
        rows.push(parseLine(l,delim));
      }
      return { rows, delim };
    }
    function isDateLike(s){
      if(!s) return false;
      const t=String(s).trim();
      if(/^\d{4}[-/]\d{2}[-/]\d{2}$/.test(t)) return true;
      const d=new Date(t); return !isNaN(d.valueOf());
    }
    function toISO(s){
      if(!s) return null;
      const t=String(s).trim();
      if(/^\d{4}[-/]\d{2}[-/]\d{2}$/.test(t)) return t.replace(/\//g,"-");
      const d=new Date(t); if(isNaN(d.valueOf())) return null;
      return d.toISOString().slice(0,10);
    }
    function parseNum(s){
      if(s==null) return null;
      let v=String(s).trim();
      if(!v) return null;
      const paren = /^\(.*\)$/.test(v); if(paren) v=v.replace(/[()]/g,"");
      v = v.replace(/\$/g,"").replace(/,/g,"");
      const n = Number(v); if(Number.isNaN(n)) return null;
      return paren ? -Math.abs(n) : n;
    }

    let __valid = [];   // {date, desc, amount, direction, source}
    let __skipped = []; // {line, reason}
    let __mode = 'A';   // 'A' amount OR 'B' debit/credit

    $("csvFile").addEventListener("change", async (e)=>{
      __valid=[]; __skipped=[];
      const f=e.target.files?.[0]; if(!f) return;
      $("impStatus").textContent="Reading file‚Ä¶";

      const text = await f.text();
      const { rows } = parseCSV(text);

      // Count parsed lines (non-null in array, including header/blank handling)
      const parsedLines = rows.filter(r => r !== undefined).length;

      // Remove completely null/blank rows for mapping purposes (keep count with __skipped later)
      const nonBlank = rows.filter(r => r && r.some(x=>String(x).trim().length));

      if(nonBlank.length===0){
        $("impStatus").className="err small";
        $("impStatus").textContent="No rows detected in this file.";
        $("countPill").textContent=`Parsed ${parsedLines} ¬∑ Valid 0 ¬∑ Skipped ${parsedLines} ¬∑ Debits 0 ¬∑ Credits 0`;
        $("impPreview").style.display="none";
        return;
      }

      // Header?
      let start = 0;
      if(nonBlank[0] && !isDateLike(nonBlank[0][0])) start = 1;

      // Column layout detection (A: Amount; B: Debit/Credit)
      __mode = 'A';
      const hdr = nonBlank[start-1] || [];
      const h2 = (hdr[2]||'').toLowerCase();
      const h3 = (hdr[3]||'').toLowerCase();
      if(/debit|withdrawal/.test(h2) || /credit|deposit/.test(h3)) __mode='B';

      let debSum=0, credSum=0;

      for(let i=start;i<nonBlank.length;i++){
        const r = nonBlank[i];
        const date = toISO(r[0]);
        const desc = String(r[1]||"").trim();
        if(!date || !desc){ __skipped.push({line:i+1,reason:'bad date/desc'}); continue; }

        let amount=null, direction='', src = (r[4]||"").trim() || null;

        if(__mode==='B'){
          const debit  = parseNum(r[2]);
          const credit = parseNum(r[3]);
          if(credit!=null && credit>0){ amount=credit; direction='credit'; credSum+=amount; }
          else if(debit!=null && debit!==0){ amount=Math.abs(debit); direction='debit'; debSum+=amount; }
          else { __skipped.push({line:i+1,reason:'no debit/credit'}); continue; }
        } else {
          const a = parseNum(r[2]);
          if(a==null){ __skipped.push({line:i+1,reason:'no amount'}); continue; }
          if(a<0){ amount=Math.abs(a); direction='debit'; debSum+=amount; }
          else if(a>0){ 
            // Use description hints for all-positive files
            const creditHit = CREDIT_RX.some(rx=>rx.test(desc));
            const debitHit  = DEBIT_RX.some(rx=>rx.test(desc));
            direction = creditHit && !debitHit ? 'credit' : (debitHit && !creditHit ? 'debit' : 'debit');
            amount = a; 
            if(direction==='credit') credSum+=amount; else debSum+=amount;
          } else { __skipped.push({line:i+1,reason:'zero amount'}); continue; }
        }

        __valid.push({date, desc, amount, direction, source: src});
      }

      const validCount   = __valid.length;
      const skippedCount = Math.max(parsedLines - (start>0?1:0) - validCount, 0);

      $("countPill").textContent = `Parsed ${parsedLines} ¬∑ Valid ${validCount} ¬∑ Skipped ${skippedCount} ¬∑ Debits ${debSum.toFixed(2)} ¬∑ Credits ${credSum.toFixed(2)}`;

      if(validCount===0){
        $("impStatus").className="err small";
        $("impStatus").textContent="No valid rows after parsing. Check date/amount formats.";
        $("impPreview").style.display="none";
        return;
      }

      // Preview first 20
      const first20 = __valid.slice(0,20);
      $("prevBody").innerHTML = first20.map(v => `
        <tr>
          <td>${esc(v.date)}</td>
          <td>${esc(v.desc)}</td>
          <td class="right">${money(v.amount)}</td>
          <td>${v.direction}</td>
          <td>${esc(v.source||"")}</td>
        </tr>
      `).join("");
      $("impPreview").style.display="block";

      $("impStatus").className="muted small";
      $("impStatus").textContent = `Ready to import ${validCount} transactions.`;
    });

    $("importGo").addEventListener("click", async ()=>{
      if(!__valid.length){ alert("No valid rows."); return; }
      if(!sb?.from){ alert("Supabase client not found."); return; }

      $("impStatus").className="muted small";
      $("impStatus").textContent=`Importing ${__valid.length} transactions‚Ä¶`;

      const rows = __valid.map(v=>({
        txn_date: v.date,
        post_date: v.date,
        description: v.desc,
        amount: v.amount,
        direction: v.direction,
        source_account_name: v.source,
        currency: "CAD",
        imported_via: "csv"
      }));

      try{
        for(let i=0;i<rows.length;i+=300){
          const chunk = rows.slice(i,i+300);
          const { error } = await sb.from("transactions").insert(chunk);
          if(error) throw error;
          $("impStatus").textContent = `Importing ${rows.length}‚Ä¶ ${Math.min(i+300,rows.length)}/${rows.length}`;
        }
        $("impStatus").className="ok small";
        $("impStatus").textContent=`‚úÖ Imported ${rows.length} transactions.`;
        $("impBackdrop").style.display="none";
        await loadTransactions();
      }catch(err){
        $("impStatus").className="err small";
        $("impStatus").textContent=String(err.message||err);
      }
    });

    // Open/close modal
    function openImporter(){ $("impBackdrop").style.display="flex"; }
    // -------- Export ----------
    async function exportCSV(){
      const { data, error } = await sb.from("transactions")
        .select("txn_date,description,amount,direction,category,source_account_name")
        .order("txn_date",{ascending:false});
      if(error){ alert(error.message); return; }
      const rows = [
        ["Date","Description","Amount","Type","Category","Source"],
        ...data.map(r=>[
          r.txn_date||"",
          (r.description||"").replace(/[\r\n]+/g," "),
          r.amount,
          r.direction,
          r.category||"",
          r.source_account_name||""
        ])
      ];
      const csv = rows.map(r=>r.map(cell=>{
        const s=String(cell??"");
        return /[",\n;]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;
      }).join(",")).join("\n");
      const blob = new Blob([csv],{type:"text/csv;charset=utf-8"});
      const a=document.createElement("a");
      a.href=URL.createObjectURL(blob); a.download="transactions_export.csv"; a.click();
      URL.revokeObjectURL(a.href);
    }

    // Boot
    loadTransactions();
  </script>
</body>
</html>
